# 最长递增子序列问题

## 问题描述
有一个长度为n的数列A = {x1, x2, x3, x4,...,xn},其最长递增子序列就是从左到右
依次选择元素，选择的元素必须满足次序与在A中的次序一致且为严格递增的子序列中最长的子序列
即为最长递增子序列。
例如：{4,2,3,1,5}的递增子序列有：{4},{4,5},{2},{2,3},{2,5},{2,3,5},{3},{3,5},{1},{1,5},{5}。
所以其最长递增子序列为{2,3,5}, len = 3.
最长递增子序列的问题有两个：1.最长递增子序列的长度是多少？2.最长递增子序列是什么？

## 思考过程
什么叫动态规划？？
【百度百科】动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。
每一个解都对应于一个值，我们希望找到具有最优值的解。其基本思想是将待求解问题分解成若干个子问题，
先求解子问题，然后从这些子问题的解得到原问题的解。
依据动态规划的思想，其状态方程为：
LIS[i] = max{A[i] > A[0]? LIS[0] + 1 : LIS[0], A[i] > A[1]? LIS[1] + 1 : LIS[1],...,
A[i] > A[i-1]? LIS[i-1] + 1 : LIS[i-1]};

### 1.最长递增子序列的长度是多少？

所以，其伪代码实现可以这样：
for i = 1...N:
    for j = 0...i-1:{
        max = A[i] > A[j]? LIS[j] + 1 : LIS[i];
        if LIS[i] < max:
            LIS[i] = max;
    }
max(LIS);//LIS的最大值即是结果。

### 2.最长递增子序列是什么？

由上可得：
for i = 1...N:{
    for j = 0...i-1:{
        max = A[i] > A[j]? LIS[j] + 1 : LIS[i];
        if LIS[i] < max{
            LIS[i] = max;
            LIS_scheme[i].push_back(A[j]); 
        }
    }
    LIS_scheme[i].push_back(A[i]);
}
LIS_scheme[max_idx[LIS]];//LIS最大值的下标（max_idx(LIS)）对应的LIS_scheme即是结果。
